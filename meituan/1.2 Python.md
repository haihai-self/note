# Python

#### （1）装饰器怎么写，传参和不传参两种，原理是啥（闭包+函数调用）

**闭包**

* 闭包就是在函数内部定义函数，内部定义的函数必须访问外部函数定义的变量

  

**装饰器**

* 装饰器就是在不影响原来函数执行的情况下，为函数新增加功能，并且对原函数没有侵入性

#### （2）字典怎么实现的：hash表

在Python3.6之前，字典是无序的，但是Python3.7+，字典是有序的。在3.6中，字典有序是一个implementation detail，在3.7才正式成为语言特性，因此3.6中无法确保100%有序。

hash的实现与c++一样。

#### （3）生成器是啥，可以用来干啥

一边循环一边计算的机制，称为生成器：generator。列表所有数据都在内存中，如果有海量数据的话将会非常耗内存。如：仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。如果列表元素按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。

生成器的目的是减少内存中数据的数量，使用时再去创建。创造生成器的两种方式：

* (x for x in range(10))
* 使用yield，原生协程可以使用yield来

#### （4）迭代器是啥、可迭代对象是啥，区别是啥：

迭代器：

* 内部实现了__ iter __ ()和__ next __()的对象

可迭代对象：

* 内部实现了__ iter __()的对象

我们使用iter(iterable)即可把可迭代对象转换成迭代器，使用next(iterator)来获取迭代器的下一个值

迭代器的区别和联系：

* 迭代器一定是可迭代的，可迭代的未必是迭代器。使用iter()方法可以将可迭代对象转换成迭代器

#### （5）python垃圾回收机制：引用计数法、分代、标记清除等：

* 引用计数法：有地方使用引用数量+1，不使用-1，等于0回收

* 标记清除：将各个对象通过引用关系连接起来，成为一个有向图，然后从根节点出发，没有被访问的节点就标记为可回收，标记完成之后，有系统回收

* 基于越新的对象越可能被回收，越老的对象越不容易回收。所以python中存在年轻代（0）、中年代（1）、老年代（2）。三者回收频率不同

#### （6）基本类型中可变类型和不可变类型有哪些，tuple可不可以做字典的键值：

   可变对象：list、dict、set

   不可变对象：string、tuple、数字

   不可变对象可以作为字典的key

要作为字典的key，对象必须要支持hash函数（即__ hash __ ），相等比较(__ eq __ 或__ cmp__ ），并且满足上面我们讨论过的条件。tuple是有这些方法的，但是list中没有 __ hash __方法 

#### （7）"abcded"操作的时候会生成新的字符串吗？

由于字符串是不可变类型，所以对字符串操**作会生成新的字符串，占用新的空间**

#### （8）Python deep copy实现代码

递归调用，用type判断类型，如果是float、int、boolean、unicode等直接返回，对于dict、list、tuple递归生成新的对象返回，对于method,使用type()生成一个新的

#### （9）GIL全局锁

 GIL（全局解释器锁)，代码执行时会去获取这个锁，对单核并影响不大，但是多核cpu只有一个核会获取到这个锁，造成极其核等待。这个锁只在Cpython这个解释器中存在，其他解释器没有这个锁。虽然有GIL，但是python依然是线程不安全的。一定情况下（IO拥塞、python2执行1000字节码/python3执行15ms），会自动释放锁。

由于GIL的影响，python无法利用多核优势，python对于计算密集型任务开多线程的效率并不能带来多大的技术提升，甚至不如串行（没有大量的切换），但是对于io密集型任务效率还是有显著的提升的

#### （10）怎么实现线程安全

使用Threading.Lock来实现，需要互斥访问的代码可以加上锁。但是加锁会导致死锁发生，死锁有两种，一种是递归锁和迭代锁，原因就是重复获取同一个锁造成的，可以使用Threadin.RLock来解决。另外一种是相互请求对方获取的锁，可以规定锁的顺序来解决。

#### （11）_, __ ,  __ xx __的意义

​    _:表示属性或者方法私有，但是只是一个君子约定，只是告诉使用者，这个是私有的，你不应该访问，还是可以直接访问的

​    _ _ : 表示方法不能被子类覆写。但是如果想要访问的话，可以通过  实例.类名称__方法()访问

​    __ xxx __ :表示魔术方法,比如__ init __ ()、__ new__()等

​            

#### (12) property的作用是啥

将方法包装成属性。需要同时设置getter和setter。getter直接使用装饰器@property，setter使用@getter名称.setter。使用时可以直接通过 “实例.方法名” 

#### （13）多继承的时候父类的遍历顺序

Python3以上是广度优先，Python2是深度优先

#### （14）魔术方法__ init __ () 与 __ new __ () 的区别

总结：先执行的__ new__ ()方法，再执行的__ init__ ()方法，__ new__ ()方法会生成一个实例，__ init__ 会对这个实例进行初始化。__ new__ 是一个静态方法，__ init__ 是一个实例方法

#### (15)包中__ init__ .py的作用、这个文件中 __ all __ = []的作用

__ init__ .py作为一个包的标识，导入这个包时首先会执行__ init__ .py的内部代码，使用 __ all __ = []暴露包中的模块。