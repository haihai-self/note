# 百度搜索架构部 一面(30min 挂！)

## 项目

    1. 多线程是怎么debug的？gdb有用过吗？
    2. LT和ET的区别？ET的读取模式？ET模式下如果写缓冲区满了程序会怎么处理？

        写缓冲区满了之后会返回EAGAIN|EWOULDBLOCK命令，这个时候程序会重新把文件描述符加入内核。

    3. 你说用到了线程池，你是怎么使用锁来保证线程安全的？

---


## C++

    1. 四种cast转换，static_cast / dynamic_cast / const_cast / reinterpret_cast
    2. share_ptr / unique_ptr . share_ptr使用在=赋值时会发生什么？
    3. new操作具体发生了什么 

---


## 操作系统

    1. 进程、线程和协程的区别

---


## 写代码

    1. 力扣192：shell命令
    2. 力扣124：二叉树的最大路径和（hard）
---


# 百度自动驾驶基础架构部门 一面（60min）

## 手撕

    1. 旋转有序数组中的最小值（二分）
    2. 矩阵中左下角到右上角的路径总数（dp，杨辉三角，Ci/(i+j)）

## C++
    1. C++为什么要有迭代器？
    2. vector/List/map/unordered_map 删除操作时迭代器的失效情况？
    3. weak_ptr?
    4. 虚函数的实现
    5. 右值

## 操作系统
    1. 多线程怎么debug的？

    
    2. 自旋锁和其他锁的区别？

    　自旋锁是专为防止多处理器并发（实现保护共享资源）而引入的一种锁机制。自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，“自旋”一词就是因此而得名。自旋锁在内核中大量应用于中断处理等部分（对于单处理器来说，防止中断处理中的并发可简单采用关闭中断的方式，即在标志寄存器中关闭/打开中断标志位，不需要自旋锁）。
    自旋锁的初衷就是：在短期间内进行轻量级的锁定。一个被争用的自旋锁使得请求它的线程在等待锁重新可用的期间进行自旋（特别浪费处理器时间），所以自旋锁不应该被持有时间过长。如果需要长时间锁定的话, 最好使用信号量。
    自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作。

    3. 进程通信、线程通信？

## 网络
    1. TCP/UDP 区别以及应用场景
    2. TCP 的三次握手和四次挥手过程

# 百度自动驾驶基础架构部门 二面（45min）

## 手撕
    1. 压缩字符串中的空格
    2. double类型的开方，精度要求1e6
    3. shell命令的一道题（不会）
    4. 翻转链表（递归、迭代）


# 京东搜索推荐部门 一面（25min）

# C++
    1. const
    2. 多态

# 手撕
    1. 两有序数组交集
    2. 接雨水